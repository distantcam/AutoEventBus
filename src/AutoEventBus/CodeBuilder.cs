using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

internal class CodeBuilder
{
    private readonly StringBuilder _stringBuilder = new();
    private int _indent = 0;

    public void AppendHeader()
    {
        AppendLine($"//------------------------------------------------------------------------------");
        AppendLine($"// <auto-generated>");
        AppendLine($"//     This code was generated by {ThisAssembly.Project.PackageProjectUrl}");
        AppendLine($"//     Version: {ThisAssembly.Project.Version}");
        AppendLine($"//     SHA: {ThisAssembly.Git.Sha}");
        AppendLine($"//");
        AppendLine($"//     Changes to this file may cause incorrect behavior and will be lost if");
        AppendLine($"//     the code is regenerated.");
        AppendLine($"// </auto-generated>");
        AppendLine($"//------------------------------------------------------------------------------");
    }
    public void StartBlock()
    {
        AppendLine("{");
        IncreaseIndent();
    }
    public void EndBlock()
    {
        DecreaseIndent();
        AppendLine("}");
    }
    public void IncreaseIndent() => _indent++;
    public void DecreaseIndent() => _indent--;
    public void AppendPragma(string pragma) => _stringBuilder.AppendLine(pragma);
    public void AppendLine() => _stringBuilder.AppendLine();
    public void AppendLine(string line) => _stringBuilder.AppendLine(new string('\t', _indent) + line);
    public void AppendLines(params string[] lines)
    {
        foreach (var line in lines)
            AppendLine(line.TrimEnd('\r'));
    }
    public IDisposable StartPartialType(ITypeSymbol type)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace
                ? null
                : type.ContainingNamespace.ToString();
        var typeKeyword = type.IsRecord
            ? "record"
            : type.IsValueType
                ? "struct"
                : "class";

        if (!string.IsNullOrEmpty(ns))
        {
            AppendLine($"namespace {ns}");
            StartBlock();
        }

        var typeStack = new Stack<string>();
        var containingType = type.ContainingType;
        while (containingType is not null)
        {
            var contTypeKeyword = containingType.IsRecord
                ? "record"
                : containingType.IsValueType
                    ? "struct"
                    : "class";
            var typeName = containingType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
            typeStack.Push(contTypeKeyword + " " + typeName);
            containingType = containingType.ContainingType;
        }

        var nestedCount = typeStack.Count;
        while (typeStack.Count > 0)
        {
            AppendLine($"partial {typeStack.Pop()}");
            StartBlock();
        }

        AppendLine($"partial {typeKeyword} {type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}");
        StartBlock();

        return new CloseBlock(this, 1 + nestedCount + (ns != null ? 1 : 0));
    }
    public static implicit operator SourceText(CodeBuilder codeBuilder) => SourceText.From(codeBuilder._stringBuilder.ToString(), Encoding.UTF8);
    private readonly struct CloseBlock : IDisposable
    {
        private readonly CodeBuilder _codeBuilder;
        private readonly int _count;
        public CloseBlock(CodeBuilder codeBuilder, int count) { _codeBuilder = codeBuilder; _count = count; }
        public void Dispose() { for (var i = 0; i < _count; i++) _codeBuilder.EndBlock(); }
    }
}
